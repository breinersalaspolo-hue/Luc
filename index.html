<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Animación Dedicatoria — L & S</title>
<style>
  :root{
    --bg:#05060a;
    --blue1:#4cc7ff;
    --blue2:#2ea0ff;
    --glow: rgba(76,199,255,.25);
    --white:#f3fbff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#030414 0%, #06081a 100%);font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--white);overflow:hidden}
  .stage{position:relative;width:100vw;height:100vh;touch-action:none}

  /* Esquinas: L y S */
  .corner{
    position:absolute;
    top:18px;
    font-weight:900;
    color:var(--blue1);
    -webkit-text-stroke: 1px rgba(0,0,0,.25);
    text-shadow:
      0 0 18px rgba(46,160,255,.14),
      0 0 40px rgba(76,199,255,.09),
      0 6px 30px rgba(0,0,0,.6);
    pointer-events:none;
    z-index:5;
    user-select:none;
  }
  .corner.l { left:18px; font-size: clamp(56px, 14vw, 120px); transform: translateY(0); }
  .corner.s { right:18px; font-size: clamp(56px, 14vw, 120px); transform: translateY(0); }

  /* Texto DOM (opcional) - invisible (usamos canvas for targets drawing) */
  .vis-text { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center; z-index:4; pointer-events:none; }

  /* Texto final Bleesd */
  .bleesd {
    position:absolute;
    top:50%;
    left: calc(50% + 120px);
    transform: translate(-10px,-50%) scale(.95);
    font-weight:900;
    font-size: clamp(28px,6vw,64px);
    color:transparent;
    -webkit-background-clip:text;
    background: linear-gradient(90deg,var(--blue2),#fff);
    text-shadow:0 0 18px rgba(46,160,255,.16),0 6px 30px rgba(0,0,0,.5);
    opacity:0;
    transition: opacity .6s ease, transform .6s ease;
    z-index:6;
  }
  .bleesd.show{ opacity:1; transform: translate(-10px,-50%) scale(1); }

  /* Small caption */
  .caption{ position:absolute; left:50%; bottom:10px; transform:translateX(-50%); color:rgba(255,255,255,.5); font-size:12px; z-index:6; pointer-events:none; }

  /* Canvas covers all */
  canvas{ position:absolute; inset:0; display:block; z-index:1 }
</style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="corner l" id="cornerL">L</div>
    <div class="corner s" id="cornerS">S</div>

    <!-- Elementos para mostrar Bleesd al final -->
    <div class="bleesd" id="bleesdText">Bleesd</div>
    <div class="caption">Animación automática — optimizado para móvil</div>

    <canvas id="c"></canvas>
  </div>

<script>
/* ======= CONFIG ======= */
const PHRASES = [
  "Lucas el más lindo",
  ": para que dedicarte una canción si al conocerte vi que eras todas"
];
// cross will be constructed after phrases
const CROSS_BLEESD = true; // show cross + Bleesd
const NOTE_CHAR = "♪";    // symbol used for notes
const MAX_PARTICLES = 1200; // cap (phones)
const SAMPLE_STEP = 8;     // sampling step when building targets (lower = more particles)

/* ======= SETUP ======= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
const stage = document.getElementById('stage');
const cornerL = document.getElementById('cornerL');
const cornerS = document.getElementById('cornerS');
const bleesdEl = document.getElementById('bleesdText');

let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;

window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

function centerOf(el){
  const r = el.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2 };
}

/* Particle class */
class Particle {
  constructor(sx, sy, tx, ty, color){
    this.x = sx; this.y = sy;
    this.sx = sx; this.sy = sy;
    this.tx = tx; this.ty = ty;
    this.vx = 0; this.vy = 0;
    this.r = (3 + Math.random()*6); // size (not used for text but for subtle scale)
    this.a = 1; // alpha
    this.arrived = false;
    this.color = color || '#6fd7ff';
    this.char = NOTE_CHAR;
    this.tween = 0.06 + Math.random()*0.06;
    // add small offset for wobble
    this.offsetX = (Math.random()-0.5)*6;
    this.offsetY = (Math.random()-0.5)*6;
  }
  update(){
    if(!this.arrived){
      // easing towards target
      const dx = (this.tx + this.offsetX) - this.x;
      const dy = (this.ty + this.offsetY) - this.y;
      this.x += dx * this.tween;
      this.y += dy * this.tween;
      // if very close mark arrived
      if(Math.hypot(dx, dy) < 2.5){
        this.arrived = true;
      }
    } else {
      // slight float when arrived
      this.y += Math.sin((this.tx + this.ty + Date.now()/300)/120) * 0.2;
    }
  }
  draw(ctx){
    ctx.save();
    ctx.globalAlpha = this.a;
    ctx.font = `${Math.max(12, Math.min(36, this.r*3))}px system-ui, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // glow
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = this.color;
    ctx.fillText(this.char, this.x, this.y);
    ctx.restore();
  }
}

/* Utility: render text to offscreen canvas and sample pixel positions as targets */
function getTargetsForText(text, options = {}) {
  const off = document.createElement('canvas');
  const octx = off.getContext('2d');
  // size relative to viewport
  const maxW = Math.min(W * 0.9, 1200);
  off.width = Math.floor(maxW);
  off.height = Math.floor(Math.min(300, H * 0.45));

  // choose font size based on text length and width
  let fontSize = Math.floor(off.width / Math.max(8, text.length) * 1.2);
  fontSize = Math.max(24, Math.min(160, fontSize));
  octx.clearRect(0,0,off.width, off.height);
  octx.fillStyle = "#fff";
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.font = `bold ${fontSize}px system-ui, Arial`;
  octx.fillText(text, off.width/2, off.height/2 + (fontSize*0.06));

  const img = octx.getImageData(0,0,off.width, off.height).data;
  const coords = [];
  const step = SAMPLE_STEP;

  for(let y = 0; y < off.height; y += step){
    for(let x = 0; x < off.width; x += step){
      const i = (y * off.width + x) * 4 + 3; // alpha index
      if(img[i] > 128){
        // map to screen coordinates (centered)
        const screenX = (W/2 - off.width/2) + x;
        const screenY = (H/2 - off.height/2) + y;
        coords.push({x: screenX, y: screenY});
      }
    }
  }
  // if too many coordinates, sample subset randomly
  if(coords.length > MAX_PARTICLES) {
    shuffle(coords);
    return coords.slice(0, MAX_PARTICLES);
  }
  return coords;
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

/* CROSS target generator */
function getCrossTargets(){
  const cx = W/2, cy = H/2;
  const barW = Math.max(10, Math.floor(W * 0.03));
  const halfH = Math.floor(Math.min(220, H * 0.18));
  const coords = [];
  // vertical bar
  for(let y = cy - halfH; y <= cy + halfH; y += SAMPLE_STEP){
    for(let x = cx - Math.floor(barW/2); x <= cx + Math.floor(barW/2); x += SAMPLE_STEP){
      coords.push({x,y});
    }
  }
  // horizontal bar
  const halfW = Math.floor(Math.min(220, W * 0.18));
  for(let x = cx - halfW; x <= cx + halfW; x += SAMPLE_STEP){
    for(let y = cy - Math.floor(barW/2); y <= cy + Math.floor(barW/2); y += SAMPLE_STEP){
      coords.push({x,y});
    }
  }
  // limit count
  shuffle(coords);
  return coords.slice(0, Math.min(MAX_PARTICLES, coords.length));
}

/* MAIN SEQUENCE CONTROL */
let particles = [];
let running = false;
let stepIndex = 0;

async function runSequence(){
  if(running) return;
  running = true;
  bleesdEl.classList.remove('show');

  // iterate phrases
  for(let p=0;p<PHRASES.length;p++){
    const text = PHRASES[p];
    const targets = getTargetsForText(text);
    await assignParticlesToTargets(targets);
    // wait showing
    await sleep(900 + Math.max(0, Math.floor(targets.length/60)*200));
    // fade away (particles reassign to next in loop — handled by next assign)
    // small pause
    await sleep(300);
  }

  // CROSS phase
  const crossTargets = getCrossTargets();
  await assignParticlesToTargets(crossTargets);
  // show Bleesd near cross
  await sleep(400);
  bleesdEl.classList.add('show');
  await sleep(1200);

  running = false;
}

/* assignParticlesToTargets: creates/assigns particles and animates until all arrived */
function assignParticlesToTargets(targets){
  return new Promise(resolve=>{
    // ensure number of particles equals targets length
    const needed = Math.min(MAX_PARTICLES, targets.length);
    // prepare spawn points alternating L and S
    const posL = centerOf(cornerL);
    const posS = centerOf(cornerS);

    // Create missing particles or reuse existing ones
    particles.length = Math.max(particles.length, needed);
    for(let i=0;i<needed;i++){
      const t = targets[i];
      let p = particles[i];
      const source = (i%2===0)? posL : posS;
      if(!p){
        // start slightly inside source area
        const sx = source.x + (Math.random()*20 - 10);
        const sy = source.y + (Math.random()*20 - 10);
        p = new Particle(sx, sy, t.x, t.y, i%2===0? 'rgba(108,217,255,1)':'rgba(46,160,255,1)');
        particles[i] = p;
      } else {
        // reposition particle to source and change target
        p.x = source.x + (Math.random()*18-9);
        p.y = source.y + (Math.random()*18-9);
        p.tx = t.x; p.ty = t.y;
        p.arrived = false;
        p.a = 1;
        p.tween = 0.06 + Math.random()*0.06;
        p.color = (i%2===0)? 'rgba(108,217,255,1)':'rgba(46,160,255,1)';
      }
    }
    // trim extra particles if any
    if(particles.length > needed){
      particles.length = needed;
    }

    // wait until all arrived (poll)
    let checkCount = 0;
    const checkInterval = setInterval(()=>{
      const arrivedCount = particles.reduce((s,p)=> s + (p.arrived?1:0), 0);
      // if few left, speed them by reducing tween
      particles.forEach(p=>{ if(!p.arrived) p.tween = Math.min(0.18, p.tween + 0.002); });
      if(arrivedCount >= particles.length || ++checkCount > 200){
        clearInterval(checkInterval);
        resolve();
      }
    }, 120);
  });
}

/* animation loop */
function loop(){
  ctx.clearRect(0,0,W,H);

  // subtle background glow (optional)
  // draw particles
  for(const p of particles){
    p.update();
    p.draw(ctx);
  }
  requestAnimationFrame(loop);
}

/* small helper */
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* start auto after small delay so layout ready */
window.addEventListener('load', async ()=>{
  // small layout wait
  await sleep(120);
  W = canvas.width = innerWidth; H = canvas.height = innerHeight;
  // kick off loop
  loop();
  // start sequence automatically
  runSequence();
});

/* allow replay on tap (optional) */
let tapCooldown = false;
stage.addEventListener('pointerdown', async ()=>{
  if(tapCooldown) return;
  tapCooldown = true;
  // clear and restart
  particles = [];
  bleesdEl.classList.remove('show');
  await runSequence();
  setTimeout(()=>{ tapCooldown = false; }, 800);
});
</script>
</body>
  </html>
